// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import 'forge-std/Script.sol';
import 'forge-std/Vm.sol';
import 'forge-std/StdJson.sol';
import {ChainIds, TestNetChainIds} from 'solidity-utils/contracts/utils/ChainHelpers.sol';
import {Create3Factory, Create3, ICreate3Factory} from 'solidity-utils/contracts/create3/Create3Factory.sol';
import {ChainHelpers} from 'solidity-utils/contracts/utils/ChainHelpers.sol';

struct Network {
  string path;
  string name;
}

library GovDeployerHelpers {
  using stdJson for string;

  /**
   * @notice this struct contains the addresses for the governance contracts.
   * @dev the addresses are decoded from the json file in the deployments folder.
   * @dev the json file is generated by the InitialDeployments.s.sol script.
   * @dev needs to be in alfabetical order to be able to be correctly de/codified
   */
  struct Addresses {
    address aavePool;
    uint256 chainId;
    address create3Factory;
    address crossChainController;
    address dataWarehouse;
    address executorLvl1;
    address executorLvl2;
    address governance;
    address governanceDataHelper;
    address governanceImpl;
    address governancePowerStrategy;
    address guardian;
    address metaDelegateHelper;
    address owner;
    address payloadsController;
    address payloadsControllerDataHelper;
    address payloadsControllerImpl;
    address permissionedExecutor;
    address permissionedPayloadsController;
    address permissionedPayloadsControllerImpl;
    address proxyAdminGovernance;
    address proxyAdminPayloadsController;
    address proxyFactory;
    address votingMachine;
    address votingMachineDataHelper;
    address votingPortal_Eth_Avax;
    address votingPortal_Eth_BNB;
    address votingPortal_Eth_Eth;
    address votingPortal_Eth_Pol;
    address votingStrategy;
  }

  /**
   * @notice this function returns the path to the json file for the given chain id.
   * @dev the path is generated based on the network name.
   */
  function getPathByChainId(
    uint256 chainId
  ) internal pure returns (string memory) {
    string memory path = string.concat(
      './deployments/', // @dev important to maintain this folder structure as governance uses this path to get the adi addresses
      ChainHelpers.getNetworkNameFromId(chainId)
    );
    return string.concat(path, '.json');
  }

  /**
   * @notice this function decodes the json file into the Addresses struct.
   * @dev the json file is generated by the InitialDeployments.s.sol script.
   * @dev the addresses are decoded from the json file.
   * @dev needs to be in alfabetical order
   */
  function decodeJson(
    string memory path,
    Vm vm
  ) internal view returns (Addresses memory) {
    string memory persistedJson = vm.readFile(path);

    Addresses memory addresses = Addresses({
      aavePool: abi.decode(persistedJson.parseRaw('.aavePool'), (address)),
      chainId: abi.decode(persistedJson.parseRaw('.chainId'), (uint256)),
      create3Factory: abi.decode(
        persistedJson.parseRaw('.create3Factory'),
        (address)
      ),
      crossChainController: abi.decode(
        persistedJson.parseRaw('.crossChainController'),
        (address)
      ),
      dataWarehouse: abi.decode(
        persistedJson.parseRaw('.dataWarehouse'),
        (address)
      ),
      executorLvl1: abi.decode(
        persistedJson.parseRaw('.executorLvl1'),
        (address)
      ),
      executorLvl2: abi.decode(
        persistedJson.parseRaw('.executorLvl2'),
        (address)
      ),
      governance: abi.decode(persistedJson.parseRaw('.governance'), (address)),
      governanceDataHelper: abi.decode(
        persistedJson.parseRaw('.governanceDataHelper'),
        (address)
      ),
      governanceImpl: abi.decode(
        persistedJson.parseRaw('.governanceImpl'),
        (address)
      ),
      governancePowerStrategy: abi.decode(
        persistedJson.parseRaw('.governancePowerStrategy'),
        (address)
      ),
      guardian: abi.decode(persistedJson.parseRaw('.guardian'), (address)),
      metaDelegateHelper: abi.decode(
        persistedJson.parseRaw('.metaDelegateHelper'),
        (address)
      ),
      owner: abi.decode(persistedJson.parseRaw('.owner'), (address)),
      payloadsController: abi.decode(
        persistedJson.parseRaw('.payloadsController'),
        (address)
      ),
      payloadsControllerDataHelper: abi.decode(
        persistedJson.parseRaw('.payloadsControllerDataHelper'),
        (address)
      ),
      payloadsControllerImpl: abi.decode(
        persistedJson.parseRaw('.payloadsControllerImpl'),
        (address)
      ),
      permissionedExecutor: abi.decode(
        persistedJson.parseRaw('.permissionedExecutor'),
        (address)
      ),
      permissionedPayloadsController: abi.decode(
        persistedJson.parseRaw('.permissionedPayloadsController'),
        (address)
      ),
      permissionedPayloadsControllerImpl: abi.decode(
        persistedJson.parseRaw('.permissionedPayloadsControllerImpl'),
        (address)
      ),
      proxyAdminGovernance: abi.decode(
        persistedJson.parseRaw('.proxyAdminGovernance'),
        (address)
      ),
      proxyAdminPayloadsController: abi.decode(
        persistedJson.parseRaw('.proxyAdminPayloadsController'),
        (address)
      ),
      proxyFactory: abi.decode(
        persistedJson.parseRaw('.proxyFactory'),
        (address)
      ),
      votingMachine: abi.decode(
        persistedJson.parseRaw('.votingMachine'),
        (address)
      ),
      votingMachineDataHelper: abi.decode(
        persistedJson.parseRaw('.votingMachineDataHelper'),
        (address)
      ),
      votingPortal_Eth_Avax: abi.decode(
        persistedJson.parseRaw('.votingPortal_Eth_Avax'),
        (address)
      ),
      votingPortal_Eth_BNB: abi.decode(
        persistedJson.parseRaw('.votingPortal_Eth_BNB'),
        (address)
      ),
      votingPortal_Eth_Eth: abi.decode(
        persistedJson.parseRaw('.votingPortal_Eth_Eth'),
        (address)
      ),
      votingPortal_Eth_Pol: abi.decode(
        persistedJson.parseRaw('.votingPortal_Eth_Pol'),
        (address)
      ),
      votingStrategy: abi.decode(
        persistedJson.parseRaw('.votingStrategy'),
        (address)
      )
    });

    return addresses;
  }

  /**
   * @notice this function encodes the Addresses struct into the json file.
   * @dev the json file is generated by the InitialDeployments.s.sol script.
   * @dev the addresses are encoded into the json file.
   * @dev needs to be in alfabetical order
   */
  function encodeJson(
    string memory path,
    Addresses memory addresses,
    Vm vm
  ) internal {
    string memory json = 'addresses';
    json.serialize('aavePool', addresses.aavePool);
    json.serialize('chainId', addresses.chainId);
    json.serialize('create3Factory', addresses.create3Factory);
    json.serialize('crossChainController', addresses.crossChainController);
    json.serialize('dataWarehouse', addresses.dataWarehouse);
    json.serialize('executorLvl1', addresses.executorLvl1);
    json.serialize('executorLvl2', addresses.executorLvl2);
    json.serialize('governance', addresses.governance);
    json.serialize('governanceDataHelper', addresses.governanceDataHelper);
    json.serialize('governanceImpl', addresses.governanceImpl);
    json.serialize(
      'governancePowerStrategy',
      addresses.governancePowerStrategy
    );
    json.serialize('guardian', addresses.guardian);
    json.serialize('metaDelegateHelper', addresses.metaDelegateHelper);
    json.serialize('owner', addresses.owner);
    json.serialize('payloadsController', addresses.payloadsController);
    json.serialize(
      'payloadsControllerDataHelper',
      addresses.payloadsControllerDataHelper
    );
    json.serialize('payloadsControllerImpl', addresses.payloadsControllerImpl);
    json.serialize('permissionedExecutor', addresses.permissionedExecutor);
    json.serialize(
      'permissionedPayloadsController',
      addresses.permissionedPayloadsController
    );
    json.serialize(
      'permissionedPayloadsControllerImpl',
      addresses.permissionedPayloadsControllerImpl
    );
    json.serialize('proxyAdminGovernance', addresses.proxyAdminGovernance);
    json.serialize(
      'proxyAdminPayloadsController',
      addresses.proxyAdminPayloadsController
    );
    json.serialize('proxyFactory', addresses.proxyFactory);
    json.serialize('votingMachine', addresses.votingMachine);
    json.serialize(
      'votingMachineDataHelper',
      addresses.votingMachineDataHelper
    );
    json.serialize('votingPortal_Eth_Avax', addresses.votingPortal_Eth_Avax);
    json.serialize('votingPortal_Eth_BNB', addresses.votingPortal_Eth_BNB);
    json.serialize('votingPortal_Eth_Eth', addresses.votingPortal_Eth_Eth);
    json.serialize('votingPortal_Eth_Pol', addresses.votingPortal_Eth_Pol);
    json = json.serialize('votingStrategy', addresses.votingStrategy);
    vm.writeJson(json, path);
  }

  function getAddresses(
    uint256 networkId,
    Vm vm
  ) internal view returns (GovDeployerHelpers.Addresses memory) {
    return
      GovDeployerHelpers.decodeJson(
        GovDeployerHelpers.getPathByChainId(networkId),
        vm
      );
  }
}

/**
 * @notice this library contains the constants for the governance contracts.
 * @dev the constants are used to salt the create3 and create2.
 */
library Constants {
  bytes32 public constant CREATE3_FACTORY_SALT =
    keccak256(bytes('Create3 Factory'));
  bytes32 public constant GOVERNANCE_SALT =
    keccak256(bytes('Aave Governance core'));
  bytes32 public constant POWER_STRATEGY_SALT =
    keccak256(bytes('Aave Power Strategy'));
  bytes32 public constant VOTING_MACHINE_SALT =
    keccak256(bytes('Aave Voting Machine'));
  bytes32 public constant VOTING_STRATEGY_SALT =
    keccak256(bytes('Aave Voting Strategy'));
  bytes32 public constant DATA_WAREHOUSE_SALT =
    keccak256(bytes('Aave Data Warehosue'));
  bytes32 public constant VOTING_PORTAL_ETH_ETH_SALT =
    keccak256(bytes('Aave Voting portal eth-eth merkle update'));
  bytes32 public constant VOTING_PORTAL_ETH_AVAX_SALT =
    keccak256(bytes('Aave Voting portal eth-avax merkle update'));
  bytes32 public constant VOTING_PORTAL_ETH_POL_SALT =
    keccak256(bytes('Aave Voting portal eth-pol merkle update'));
  bytes32 public constant VOTING_PORTAL_ETH_BNB_SALT =
    keccak256(bytes('Aave Voting portal eth-bnb'));
  bytes32 public constant PAYLOADS_CONTROLLER_SALT =
    keccak256(bytes('Aave Payloads Controller'));
  bytes32 public constant PERMISSIONED_PAYLOADS_CONTROLLER_SALT =
    keccak256(bytes('Aave Permissioned Payloads Controller'));
  bytes32 public constant PERMISSIONED_EXECUTOR_SALT =
    keccak256(bytes('Aave Permissioned Executor'));
  bytes32 public constant EXECUTOR_LVL1_SALT =
    keccak256(bytes('Aave Executor Lvl 1'));
  bytes32 public constant EXECUTOR_LVL2_SALT =
    keccak256(bytes('Aave Executor Lvl 2'));
  bytes32 public constant GOV_DATA_HELPER_SALT =
    keccak256(bytes('Aave Governance data helper'));
  bytes32 public constant VM_DATA_HELPER_SALT =
    keccak256(bytes('Aave Voting Machine data helper'));
  bytes32 public constant PC_DATA_HELPER_SALT =
    keccak256(bytes('Aave Payloads Controller data helper'));
  bytes32 public constant MD_DATA_HELPER_SALT =
    keccak256(bytes('Aave Meta Delegate data helper'));
}

abstract contract GovBaseScript is Script {
  function TRANSACTION_NETWORK() public view virtual returns (uint256);

  function getAddresses(
    uint256 networkId
  ) external view returns (GovDeployerHelpers.Addresses memory) {
    return
      GovDeployerHelpers.decodeJson(
        GovDeployerHelpers.getPathByChainId(networkId),
        vm
      );
  }

  function _getAddresses(
    uint256 networkId
  ) internal view returns (GovDeployerHelpers.Addresses memory) {
    try this.getAddresses(networkId) returns (
      GovDeployerHelpers.Addresses memory addresses
    ) {
      return addresses;
    } catch (bytes memory) {
      GovDeployerHelpers.Addresses memory empty;
      return empty;
    }
  }

  function _setAddresses(
    uint256 networkId,
    GovDeployerHelpers.Addresses memory addresses
  ) internal {
    GovDeployerHelpers.encodeJson(
      GovDeployerHelpers.getPathByChainId(networkId),
      addresses,
      vm
    );
  }

  function _execute(
    GovDeployerHelpers.Addresses memory addresses
  ) internal virtual;

  function run() public {
    vm.startBroadcast();
    // ----------------- Persist addresses -----------------------------------------------------------------------------
    GovDeployerHelpers.Addresses memory addresses = _getAddresses(
      TRANSACTION_NETWORK()
    );
    // -----------------------------------------------------------------------------------------------------------------
    _execute(addresses);
    // ----------------- Persist addresses -----------------------------------------------------------------------------
    _setAddresses(TRANSACTION_NETWORK(), addresses);
    // -----------------------------------------------------------------------------------------------------------------
    vm.stopBroadcast();
  }
}
